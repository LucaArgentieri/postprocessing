import {
	BoxGeometry,
	Color,
	Euler,
	Group,
	InstancedMesh,
	LightProbe,
	Matrix4,
	Mesh,
	MeshStandardMaterial,
	PlaneGeometry,
	PointLight,
	Quaternion,
	SphereGeometry,
	Vector3
} from "three";

/**
 * Creates lights.
 *
 * @return The lights.
 */

export function createLights(): Group {

	// Generated by rendering the environment with an ambient light value of 0x523f1c.
	const shCoefficients = [
		[0.12324091787538365, 0.09064047524231066, 0.05263591868309067],
		[0.07505564151881193, 0.07505564221782213, 0.07505564728562912],
		[-1.2738801795225628e-18, -1.3862720782180785e-18, 7.2901209466271645e-19],
		[-0.022844675139794938, 0.013457944286841193, -2.555398129446308e-20],
		[-6.378735628644095e-19, 3.723254872321192e-19, -4.827259490682807e-20],
		[-7.1448287739362375e-19, -1.307481902513501e-18, -9.613106193675661e-19],
		[-0.037415948039784014, -0.041434962772114364, -0.044504851419885576],
		[3.0317816726499583e-20, -4.584564755673668e-20, 4.745534065260507e-21],
		[-0.09868906531272167, -0.09172794146160522, -0.0864107588144471]
	];

	const lightProbe = new LightProbe();
	lightProbe.sh.coefficients = shCoefficients.map(x => new Vector3(x[0], x[1], x[2]));

	const lightCeiling = new PointLight(0xd9a859, 1, 10);
	lightCeiling.position.set(0, 0.84, 0);
	lightCeiling.castShadow = true;
	lightCeiling.shadow.bias = -0.015;
	lightCeiling.shadow.mapSize.width = 1024;
	lightCeiling.shadow.mapSize.height = 1024;
	lightCeiling.shadow.radius = 4;
	lightCeiling.shadow.camera.near = 0.1;

	const lights = new Group();
	lights.add(lightProbe, lightCeiling);

	return lights;

}

/**
 * Creates the environment.
 *
 * @return The environment.
 */

export function createEnvironment(): Group {

	const planeGeometry = new PlaneGeometry();
	const planeMaterial = new MeshStandardMaterial({ color: 0xffffff });

	const mesh = new InstancedMesh(planeGeometry, planeMaterial, 7);
	mesh.receiveShadow = true;

	const p = new Vector3();
	const q = new Quaternion();
	const e = new Euler();
	const s = new Vector3();
	const m = new Matrix4();
	const c = new Color();

	mesh.setMatrixAt(0, m.compose(p.set(0, -1, 0), q.setFromEuler(e.set(Math.PI * 0.5, 0, 0)), s.set(2, 2, 1)));
	mesh.setMatrixAt(1, m.compose(p.set(0, -1, 0), q.setFromEuler(e.set(Math.PI * -0.5, 0, 0)), s.set(2, 2, 1)));
	mesh.setMatrixAt(2, m.compose(p.set(0, 1, 0), q.setFromEuler(e.set(Math.PI * 0.5, 0, 0)), s.set(2, 2, 1)));
	mesh.setMatrixAt(3, m.compose(p.set(0, 0, -1), q.identity(), s.set(2, 2, 1)));
	mesh.setMatrixAt(4, m.compose(p.set(0, 0, 1), q.setFromEuler(e.set(0, Math.PI, 0)), s.set(2, 2, 1)));

	mesh.setMatrixAt(5, m.compose(p.set(-1, 0, 0), q.setFromEuler(e.set(0, Math.PI * 0.5, 0)), s.set(2, 2, 1)));
	mesh.setMatrixAt(6, m.compose(p.set(1, 0, 0), q.setFromEuler(e.set(0, Math.PI * -0.5, 0)), s.set(2, 2, 1)));

	mesh.setColorAt(5, c.setHex(0xff0000));
	mesh.setColorAt(6, c.setHex(0x00ff00));

	const ceilingLightMesh = new Mesh(
		planeGeometry,
		new MeshStandardMaterial({
			color: 0xffffff,
			emissive: 0xffffff
		})
	);

	ceilingLightMesh.position.y = 1 - 0.004;
	ceilingLightMesh.rotation.x = Math.PI * 0.5;
	ceilingLightMesh.scale.set(0.4, 0.4, 1);

	const environment = new Group();
	environment.add(mesh, ceilingLightMesh);

	return environment;

}

/**
 * Creates the scene actors.
 *
 * @return The actors.
 */

export function createActors(): Group {

	const actor01 = new Mesh(
		new BoxGeometry(1, 1, 1),
		new MeshStandardMaterial({
			color: 0xffffff,
			roughness: 0.5,
			metalness: 0
		})
	);

	const actor02 = new Mesh(
		new BoxGeometry(1, 1, 1),
		new MeshStandardMaterial({
			color: 0xffffff,
			roughness: 1,
			metalness: 0
		})
	);

	const actor03 = new Mesh(
		new SphereGeometry(1, 32, 32), new MeshStandardMaterial({
			color: 0xffffff,
			roughness: 0.25,
			metalness: 0.25
		})
	);

	const zFightingBias = 1e-4;

	actor01.position.set(-0.35, -0.4 + zFightingBias, -0.3);
	actor01.rotation.y = Math.PI * 0.1;
	actor01.scale.set(0.6, 1.2, 0.6);
	actor01.castShadow = true;

	actor02.position.set(0.35, -0.7 + zFightingBias, 0.3);
	actor02.rotation.y = Math.PI * -0.1;
	actor02.scale.set(0.6, 0.6, 0.6);
	actor02.castShadow = true;

	actor03.position.set(-0.5, -0.7 + zFightingBias, 0.6);
	actor03.scale.set(0.3, 0.3, 0.3);
	actor03.castShadow = true;

	const actors = new Group();
	actors.add(actor01, actor02, actor03);

	return actors;

}
